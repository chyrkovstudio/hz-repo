= Configuring CP Subsystem
:description: You can configure clusters to enable the CP Subsystem as well as fine-tune many other options such as CP groups sizes and persistence of CP state.
:page-aliases: persistence.adoc
:page-enterprise: true

{description}

== Quickstart Configuration

Use this quickstart to test CP Subsystem in development.

NOTE: Before going into production, make sure to read the <<production-checklist, Production Checklist>> section.

By default, CP Subsystem runs in unsafe mode, which means it is disabled. To enable the CP Subsystem, you must first configure a non-zero value for the <<cp-member-count, `cp-member-count`>> option:

[[cp-member-count]]
[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <cp-member-count>3</cp-member-count>
    <!-- configuration options here -->
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    cp-member-count: 3
    # configuration options here

----
--
Java:: 
+ 
--
Use the link:https://javadoc.io/doc/com.hazelcast/hazelcast/{full-version}/com/hazelcast/config/cp/CPSubsystemConfig.html[`CPSubsystemConfig`] object.

[source,java]
----
Config config = new Config();

config.getCPSubsystemConfig()
.setCPMemberCount(3)
----
--
====

== Production Checklist

Before you start configuring members, consider the following checklist:

- [ ] Are you already <<persistence, persisting AP data structures in the same cluster>>?

NOTE: Running clusters must be restarted before any configuration changes take effect.

[[persistence]]
== Persisting CP Data Structures
[.enterprise]*{enterprise-product-name}*

To enable xref:cp-subsystem:cp-subsystem.adoc#persistence[CP Subsystem Persistence], set the <<persistence-enabled, `persistence-enabled`>> option to `true`.

When CP Subsystem Persistence is enabled, all Hazelcast cluster members, including AP members, create
a sub-directory under the base `cp-data` directory. CP members persist CP state in these sub-directories. AP members persist only
their status as non-CP members.

NOTE: If you have both CP and AP members in
your cluster when CP Subsystem Persistence is enabled, and if you want to
perform a cluster-wide restart, you need to ensure that AP members are also
restarted with their CP persistence stores.

To change the base directory, set a value in the <<base-dir, `base-dir`>> option.

[[ap-cp]]
=== CP Subsystem Persistence and AP Persistence

As well as CP Subsystem Persistence, Hazelcast offers xref:storage:persistence.adoc[Persistence] for some AP data structures. If you persist AP and CP data structures in a single
Hazelcast cluster, be aware that member or cluster restarts can fail because of either the persisted AP data structures or the CP data structures.

== Choosing a Group Size

For all xref:cp-subsystem.adoc#cp-groups[CP groups], you can set the number of CP members
that should participate in each one, using the <<group-size, `group-size`>> option.

To scale out throughput and memory capacity, you can choose a CP group size that is
smaller than the <<cp-member-count, CP member count>> to distribute your CP data structures to multiple CP groups.

CP groups usually consist of an odd number of CP members between three and seven, i.e., it should be either three, five, or seven.
An odd number of CP members in a group is more advantageous to an even number because of the quorum or majority calculations.

For a CP group of `N` members:

* the majority of members is calculated as `(N + 1) / 2`.
* the number of failing members you wish to tolerate is calculated as `(N - 1) / 2`.

For example, in a CP group of five CP members, operations are committed when they are
replicated to at least three CP members. This CP group can tolerate the failure of two CP
members and remain available.

[NOTE]
====
We recommend that you create the minimum number of CP groups that you think are sufficient for your CP subsystem use case.
Creating separate CP groups allows clients to distribute the load among the leaders of several CP groups.
However, a large number of CP groups running on the same members may slow down the system.
If you have accidentally or intentionally created a large number of CP groups, and don't have plans to use them anymore,
you should xref:cp-subsystem:management.adoc#destroying-a-cp-group-by-force[destroy them].
====

[[configuring-leadership-priority]]
== Configuring Leadership Priority

Some CP members are better leadership candidates than others. For example, members in your primary data center make better leaders because of the reduced latency between clients and the leader. Whereas, members under high load are not good candidates because they are more likely to suffer from downtime. To ensure the availability of the CP subsystem, you can configure CP members with a priority rating, using the <<cp-member-priority, `cp-member-priority`>> option.

Initially, any CP member with any priority can become a leader (`cp-member-priority` is not therefore taken into account during the leader election processes). But, the backgound leadership rebalancing task periodically transfers the leadership from CP members with the lowest priorities to those with higher priorities within each CP group. Eventually, all CP group leaders are CP members with high priorities.

NOTE: Only CP members that are part of a CP group can become leaders. CP members that are not in a CP group do not participate in the leadership rebalancing task. For example, you start a cluster with the CP group size set to three and three CP members with priority 0. Later, you promote a new CP member with priority 100. Even though it has a higher priority, the new CP member never becomes a leader because the CP group is full. The new CP member is eligible for leadership only when a CP member leaves the CP group and the new CP member takes the previous member's place.

[[sessions]]
== Configuring CP Sessions

xref:cp-subsystem:cp-subsystem.adoc#sessions[Sessions] offer a trade-off between liveliness and safety. If you set a
small value for the <<session-time-to-live-seconds,`session-time-to-live-seconds`>> option, a
session owner could be considered crashed very quickly and its resources can be
released prematurely. On the other hand, if you set a large value, a session
could be kept alive for an unnecessarily long duration even if its owner
actually crashes. However, it is a safer approach to not use a small session
`session-time-to-live-seconds` duration. If a session owner is known to be crashed, its session could be closed manually.

[[fencedlock-configuration]]
== Configuring Fenced Locks

By default, fenced locks are reentrant. When a caller acquires the lock, it can
acquire the lock reentrantly as many times as it wants in a linearizable manner.

You can configure the reentrancy behavior in the <<lock-acquire-limit,`lock-acquire-limit`>> option. For example,
reentrancy can be disabled by setting this option to `1`, making the lock a non-reentrant mutex. You can also set a custom reentrancy limit. When the reentrancy limit is already reached, the fenced lock does not block a lock call. Instead, it fails
with `LockAcquireLimitReachedException` or a specified return value.

== Configuring Semaphores

By default, a caller must
acquire permits before releasing them and it cannot release a permit
that it has not acquired. This means that you can acquire a permit
from one thread and release it from another thread, using the same
caller, but not different callers. In this mode,
acquired permits are automatically released upon failure of the caller.

To enable a permit to be released without acquiring it first, enable JDK compatibility by setting the <<jdk-compatibility,`jdk-compatibility`>> option to `true`. Because
acquired permits are not bound to threads.

WARNING: When `jdk-compatibility` is set to `true`, Hazelcast does not
auto-cleanup acquired permits upon caller failures. If a permit holder fails, its permits must be released manually.

[[remove]]
== Removing Missing CP Members Automatically

If CP Subsystem Persistence is disabled, CP members lose their state after shutting down and so cannot rejoin the CP Subsystem. You can configure CP members to be automatically removed from the CP Subsystem after they shut down as well as how long to wait after they shut down before removing them.

By default, missing CP members are automatically removed
from the CP Subsystem after 4 hours and replaced with other
available CP members in all its CP groups. You can configure this time, using the <<missing-cp-member-auto-removal-seconds,`missing-cp-member-auto-removal-seconds`>> option.

If a missing CP member rejoins the cluster after it is automatically removed from the
CP Subsystem, that CP member must be terminated manually.

If no CP members are available to replace a missing CP member, the group size of any groups that it was in is reduced and the majority values are recalculated.

NOTE: When CP Subsystem Persistence is enabled, CP members are not automatically removed from the CP
Subsystem. These CP members can restore their CP state from disk and rejoin their CP groups. It is your responsibility to xref:management.adoc#removing-a-cp-member[remove CP members] if they do not restart.

[[IndeterminateOperationStateException]]
== Handling Indeterminate Operation State

When you invoke an API method on a CP data structure, the method
replicates an internal operation to the corresponding CP group. After the CP leader commits this
operation to the majority of the CP group, it
sends a response to the public API call. If a failure causes loss of the response, then the caller cannot determine if the operation is committed on the CP group or not.

You can handle loss of the response in two ways:

- To allow CP leaders to replicate the operation to the CP group multiple times, set the <<fail-on-indeterminate-operation-state,`fail-on-indeterminate-operation-state`>> option to `false` (default).
- To send an `IndeterminateOperationStateException` back to the caller, set the `fail-on-indeterminate-operation-state` option to `true`.

== Global Configuration Options

Use these configuration options to configure the CP Subsystem.

[[fenced-lock-config]]
== Fenced Lock Options

Use the following options to configure fenced locks:

[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <locks>
      <fenced-lock>
        <!-- insert configuration options here -->
      </fenced-lock>
    </locks>
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    locks:
      # insert configuration options here
----
--
Java:: 
+ 
--
Add configuration options to the link:https://javadoc.io/doc/com.hazelcast/hazelcast/{full-version}/com/hazelcast/config/cp/FencedLockConfig.html[`FencedLockConfig` object].

[source,java]
----
Config config = new Config();

FencedLockConfig lockConfig = new FencedLockConfig(/*options*/);

config.getCPSubsystemConfig().addLockConfig(lockConfig);
----
--
====

[cols="1a,1a,1m,2a",options="header"]
|===
|Option|Description|Default|Example

|[[name]]`name`
|The name of the fenced lock to configure.

a|' ' (empty)
|

[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <locks>
      <fenced-lock>
        <name>lock1</name>
      </fenced-lock>
    </locks>
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    locks:
      lock1:
----
--
Java:: 
+ 
--
[source,java]
----
Config config = new Config();

FencedLockConfig lockConfig = new FencedLockConfig(lock1, /*acquire limit*/);

config.getCPSubsystemConfig().addLockConfig(lockConfig);
----
--
====

|[[lock-acquire-limit]]`lock-acquire-limit`
|Maximum number of reentrant lock acquisitions. Once a caller acquires the lock this many times, it will not be able to acquire the lock again, until it makes at least one `unlock()` call. If lock-acquire-limit is set to `1`, then the lock becomes non-reentrant.
a|`0` (no limit)
|
[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <locks>
      <fenced-lock>
        <name>lock1</name>
        <acquire-limit>1</acquire-limit>
      </fenced-lock>
    </locks>
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    locks:
      lock1:
        lock-acquire-limit: 1

----
--
Java:: 
+ 
--
[source,java]
----
Config config = new Config();

FencedLockConfig lockConfig = new FencedLockConfig(lock1, 1);

config.getCPSubsystemConfig().addLockConfig(lockConfig);
----
--
====
|===

[[semaphore-config]]
== Semaphore Options

Use the following options to configure semaphores:

[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    < semaphores >
      <semaphore>
        <!-- insert configuration options here -->
      </semaphore >
    </semaphores >
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    semaphores:
      # insert configuration options here
----
--
Java:: 
+ 
--
Add configuration options to the link:https://javadoc.io/doc/com.hazelcast/hazelcast/{full-version}/com/hazelcast/config/cp/SemaphoreConfig.html[`SemaphoreConfig` object].

[source,java]
----
Config config = new Config();

SemaphoreConfig semaphoreConfig = new SemaphoreConfig(/*insert configuration options here*/);

config.getCPSubsystemConfig().addSemaphoreConfig(semaphoreConfig);
----
--
====

[cols="1a,1a,1m,2a",options="header"]
|===
|Option|Description|Default|Example


|[[semaphore-name]]`name`
|Name of the semaphore.
a|' ' (empty)

|
[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <semaphores>
      <semaphore>
          <name>sem1</name>
      </semaphore>
    </semaphores>
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    semaphores:
      sem1:
----
--
Java:: 
+ 
--
[source,java]
----
Config config = new Config();

SemaphoreConfig semaphoreConfig = new SemaphoreConfig("sem1");

config.getCPSubsystemConfig().addSemaphoreConfig(semaphoreConfig);
----
--
====

|[[jdk-compatible]]`jdk-compatible`
|Whether JDK compatibility is enabled. See <<semaphores, Semaphores>>.

|false

|
[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <semaphores>
      <semaphore>
          <name>sem1</name>
          <jdk-compatible>false</jdk-compatible>
      </semaphore>
    </semaphores>
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    semaphores:
      sem1:
        jdk-compatible: false
----
--
Java:: 
+ 
--
[source,java]
----
Config config = new Config();

SemaphoreConfig semaphoreConfig = new SemaphoreConfig("sem1", false);

config.getCPSubsystemConfig().addSemaphoreConfig(semaphoreConfig);
----
--
====

|[[initial-permits]]`initial-permits`
|Number of permits to initialize the semaphore. If a positive value is set, the semaphore is initialized with the given number of permits.
|0
|
[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <semaphores>
      <semaphore>
          <name>sem1</name>
          <initial-permits>1</initial-permits>
      </semaphore>
    </semaphores>
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    semaphores:
      sem1:
        initial-permits: 1
----
--
Java:: 
+ 
--
[source,java]
----
Config config = new Config();

SemaphoreConfig semaphoreConfig = new SemaphoreConfig("sem1", false, 1);

config.getCPSubsystemConfig().addSemaphoreConfig(semaphoreConfig);
----
--
====
|===

[[cpmap-config]]
== CPMap Options

Use the following options to configure `CPMap` instances:

[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <maps>
      <map>
        <!-- insert configuration options here -->
      </map >
    </maps >
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    maps:
      # insert configuration options here
----
--
Java:: 
+ 
--
Add configuration options to the link:https://javadoc.io/doc/com.hazelcast/hazelcast/{full-version}/com/hazelcast/config/cp/CPMapConfig.html[`CPMap` object].

[source,java]
----
Config config = new Config();

CPMapConfig cpMapConfig = new CPMapConfig(/*insert configuration options here*/);

config.getCPSubsystemConfig().addCPMapConfig(cpMapConfig);
----
--
====

[cols="1a,1a,1m,2a",options="header"]
|===
|Option|Description|Default|Example


|[[cpmap-name]]`name`
|Name of the CPMap.
a|' ' (empty)

|
[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <maps>
      <map>
          <name>map1</name>
      </map>
    </maps>
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    maps:
      map1:
----
--
Java:: 
+ 
--
[source,java]
----
Config config = new Config();

CPMapConfig cpMapConfig = new CPMapConfig("map1");

config.getCPSubsystemConfig().addCPMapConfig(cpMapConfig);
----
--
====

|[[max-size-mb]]`max-size-mb`
|Maximum permitted size in MB for the totality of key-value data. The maximum permitted size is 2000MB.

|100

|
[tabs] 
==== 
XML:: 
+ 
--
[source,xml]
----
<hazelcast>
  <cp-subsystem>
    <maps>
      <map>
          <name>map1</name>
          <max-size-mb>50</max-size-mb>
      </map>
    </maps>
  </cp-subsystem>
</hazelcast>
----
--
YAML:: 
+ 
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    maps:
      map1:
        max-size-mb: 50
----
--
Java:: 
+ 
--
[source,java]
----
Config config = new Config();

CPMapConfig cpMapConfig = new CPMapConfig("map1", 50);

config.getCPSubsystemConfig().addCPMapConfig(cpMapConfig);
----
--
====

|===

[[raft]]
== Raft Algorithm Options

Use these options to fine-tune the Raft
consensus algorithm.

WARNING: Do not change these settings unless you know what you're doing.

[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    <cp-subsystem>
        <raft-algorithm>
          <!-- insert configuration options here -->
        </raft-algorithm>
    </cp-subsystem>
</hazelcast>
----
--

YAML::
+
--
[source,yaml]
----
hazelcast:
  cp-subsystem:
    raft-algorithm:
      # insert configuration options here
----
--

Java::
+
--
Add configuration options to the link:https://javadoc.io/doc/com.hazelcast/hazelcast/{full-version}/com/hazelcast/config/cp/RaftAlgorithmConfig.html[`RaftAlgorithmConfig` object].

[source,java]
----
Config config = new Config();

RaftAlgorithmConfig raftConfig = new RaftAlgorithmConfig();

config.getCPSubsystemConfig().setRaftAlgorithmConfig(raftConfig);
----
--
====

