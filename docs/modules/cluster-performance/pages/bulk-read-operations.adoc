= Best Practices For IMap Bulk Read Operations

[[best-practices-for-imap-bulk-read-operations]]

Avoiding an Out of Memory Error (OOME) is critical, as its impact
can be severe. Even though Hazelcast strives to protect your data,
an OOME can lead to a loss of cluster availability. This can result
in increased operation latencies due to triggered migrations. From
your application's perspective, an OOME could also cause a system
crash. Certain IMap API calls are particularly risky in this regard.

*Methods like `entrySet()` and `values()` can trigger an OOME*, depending
on the size of your map and the available memory on each member.
To mitigate this risk, following best practices is essential.

== Best Practices to Prevent OOM with IMap API Calls
To safeguard your cluster and application from
OOM, follow best practices and consider using the
following alternatives to bulk read operations:

=== Plan Capacity
Proper capacity planning is crucial for providing
sufficient system resources to the Hazelcast cluster. This
involves estimating and validating the cluster's capacity
(memory, CPU, disk, etc.) to determine the best practices
that will help the cluster achieve optimal performance.

See xref:ROOT:capacity-planning.adoc[Capacity Planning] for more information.

=== Limit Query Result Size
Limiting query result sizes can help prevent the adverse effects of bulk data reads.

[source,java]
----
Set<Map.Entry<K, V>> entrySet();
Set<Map.Entry<K, V>> entrySet(Predicate<K, V> predicate);
----
See xref:data-structures:preventing-out-of-memory.adoc#configuring-query-result-size[Configuring Query Result Size] for more details.

=== Use Iterator
The Iterator fetches data in batches, ensuring consistent heap
utilization. The relevant methods in the IMap API include:

[source,java]
----
Iterator<Entry<K, V>> iterator();
Iterator<Entry<K, V>> iterator(int fetchSize);
----

[source,java]
----
IMap<Integer, Integer> testMap = instance.getMap("test");
for (int i = 0; i < 1_000; i++) {
    testMap.set(i, i);
}

// default fetch size is 100 element
Iterator<Map.Entry<Integer, Integer>> iterator = testMap.iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, Integer> next = iterator.next();
    System.err.println(next);
}
----


=== Use PartitionPredicate
Filtering with *PartitionPredicate* can reduce memory overhead during bulk operations.

See xref:query:predicate-overview.adoc#filtering-with-partition-predicate[PartitionPredicate] for more information.


=== Use EntryProcessor
In some scenarios, reversing the traditional approach can be
more effective. Instead of fetching all data to the local
application for processing, you can send operations directly to
the data. This in-place processing method saves both time and
resources. *EntryProcessor* is an excellent tool for this purpose.

See xref:data-structures:entry-processor.adoc[Entry Processor] for more details.

=== Use SqlService


