= Vector Collection
:page-enterprise: true
:page-beta: true

== Intro

The primary object for interacting with the vector storage is a Vector Collection. This collection holds information about the vectors and associated metadata (user value).

A collection consists of one or more indexes, all sharing a common metadata storage. Each index represents a distinct vector space. Vectors from different indexes are stored independently, and indexes can have different configurations.

Conceptually, a vector collection resembles a key-value store. Here, the key is a user-defined unique identifier, and the value is an object containing metadata (user value) alongside several vectors â€” one for each index.

Users are permitted to store any necessary value for work as metadata (user value). This can be additional characteristics of the source data or even the source data itself.

== Configuration
:stem: latexmath
Collection configuration can be set dynamically during vector collection creation or statically during cluster configuration. Unlike other data structures, the configuration must be set up before the collection can be used.
There is no default configuration for the vector collection. If no matching configuration is found for the specified vector collection, the system will raise an error.

The configuration supports wildcards. Therefore, to retrieve a VectorCollection, the system will search for an exact match of the requested collection name in the configuration, or it will use a wildcard match from the existing configurations.

Below is a table listing all available options:

.Collection configuration options
[cols="1,2,1,1",options="header"]
|===
|Option|Description|Required|Default

|name
|The name of the vector collection.
Can include letters, numbers, and the symbols `-`, `_`, `*`.
|Required
|`NULL`

|indexes
|Information about indexes configuration
|Required
|`NULL`
|===

.Index configuration options
[cols="1,2,1,1",options="header"]
|===
|Option|Description|Required|Default

|name
|The name of the vector index.
Can include letters, numbers, and the symbols `-` and `_`.
|Required - for single-index vector collections. Optional - for multi-index collection
|`NULL`

|dimension
|Vectors dimension
|Required
|`N/A`

|metric
|Distance metric used to calculate the distance between two vectors.
See table <<available-metrics, Available distance metrics.>>
|Required
|`N/A`

|max-degree
|The maximum number of neighbors per node is calculated as max-degree * 2
|Required
|`16`

|ef-construction
|The size of the search queue to use when finding nearest neighbors.
|Required
|`100`

|use-deduplication
|The option for vector deduplication.
When disabled, each added vector will be treated as a distinct vector in the index, even if it is identical to an existing one. When deduplication is enabled, the index consumes less space, but the time required to add a vector increases.
|Required
|`TRUE`

|===

[#available-metrics]
.Available distance metrics
[cols="2,2,2a",options="header"]
|===
|Name|Description| Score definition

|EUCLIDEAN
|euclidean distance
|stem:[\begin{align*}\frac{1}{1 + d(\vec{v1}, \vec{v2})}\end{align*}]

|COSINE
|cosine of the angle between the vectors
| stem:[\begin{align*}\frac{1 + \cos(\vec{v1}, \vec{v2})}{2}\end{align*}]

|DOT
|dot product of the vectors
| stem:[\begin{align*}\frac{1 + \vec{v1} \cdot \vec{v2}}{2}\end{align*}]
|===

NOTE: The recommended method for computing cosine similarity is to normalize all vectors to unit length and utilize the DOT metric instead.


Configuration example:

[tabs]
====
XML::
+
--
[source,xml]
----
<hazelcast>
    <vector-collection name="books">
        <indexes>
            <index name="word2vec-index">
                <dimension>6</dimension>
                <metric>DOT</metric>
            </index>
            <index name="glove-index">
                <dimension>10</dimension>
                <metric>DOT</metric>
                <max-degree>32</max-degree>
                <ef-construction>256</ef-construction>
                <use-deduplication>false</use-deduplication>
            </index>
        </indexes>
    </vector-collection>
</hazelcast>
----
--
YAML::
+
--
[source,yaml]
----
hazelcast:
  vector-collection:
    vector-collection-name:
      indexes:
        - name: word2vec-index
          dimension: 6
          metric: DOT
        - name: glove-index
          dimension: 10
          metric: DOT
          max-degree: 32
          ef-construction: 256
          use-deduplication: false
----
--
Java::
+
--
[source,java]
----
Config config = new Config();
VectorCollectionConfig collectionConfig = new VectorCollectionConfig("books")
    .addVectorIndexConfig(
            new VectorIndexConfig()
                .setName("word2vec-index")
                .setDimension(6)
                .setMetric(Metric.DOT)
    ).addVectorIndexConfig(
            new VectorIndexConfig()
                .setName("glove-index")
                .setDimension(10)
                .setMetric(Metric.DOT)
                .setMaxDegree(32)
                .setEfConstruction(256)
                .setUseDeduplication(false)
    );
config.addVectorCollectionConfig(collectionConfig);
----
--
Python::
+
--
[source,python]
----
client.create_vector_collection_config("books", indexes=[
    IndexConfig(name="word2vec-index", metric=Metric.DOT, dimension=6),
    IndexConfig(name="glove-index", metric=Metric.DOT, dimension=10,
                max_degree=32, ef_construction=256, use_deduplication=False),
])
----
--
====

== Create collection

=== Get vector collection
To get the collection, use one of the static methods of `VectorCollection`. Both methods will either create a new vector collection or return an existing one corresponding to the requested name.

* Method `getCollection(HazelcastInstance instance, VectorCollectionConfig collectionConfig)`.
** If a collection with the provided name does not exist, a new collection will be created with the given configuration. If the configuration for the collection already exists, the provided configuration should match the one created earlier; otherwise, an error will be thrown.
** If a collection with the same name and configuration already exists, it will be returned.
** If a collection with the same name but a different configuration exists, an error will be thrown.

[tabs]
====
Java::
+
--
[source,java]
----
VectorCollectionConfig collectionConfig = new VectorCollectionConfig("books")
    .addVectorIndexConfig(
            new VectorIndexConfig()
                .setDimension(6)
                .setMetric(Metric.DOT)
    );
VectorCollection vectorCollection = VectorCollection.getCollection(hazelcastInstance, vectorCollectionConfig);
----
--
Python::
+
--
[source,python]
----
# create configuration and get collection separately
client.create_vector_collection_config("books", indexes=[
    IndexConfig(name=None, metric=Metric.DOT, dimension=6)
])
vectorCollection = client.get_vector_collection("books").blocking()
----
--
====

* Method `getCollection(HazelcastInstance instance, String collectionName)`.
** If a collection with the provided name does not exist, the system will create the collection with the configuration created explicitly during static or dynamic configuration of the cluster. If the configuration does not exist, an error will be thrown.
** If a collection with the provided name exists, it will be returned.

[tabs]
====
Java::
+
--
[source,java]
----
VectorCollection vectorCollection = VectorCollection.getCollection(hazelcastInstance, "books");
----
--
Python::
+
--
[source,python]
----
vectorCollection = client.get_vector_collection("books").blocking()
----
--
====

NOTE: Java Vector Collection API is only async, Python provides both async and sync API (via `blocking()`)

== Manage data
All methods of `VectorCollection` that work with collection data are asynchronous. The result is returned as a `CompletionStage`. A collection interacts with entries in the form of documents (`VectorDocument`). Each document comprises a value and one or more vectors associated with that value.

WARNING: When using the asynchronous methods, clients should carefully control the number of requests and their concurrency. A large number of requests can potentially overwhelm both the server and the client by consuming significant heap memory during processing.

=== Create document
To create a document use the static factory methods of `VectorDocument` and `VectorValues` classes.

Example document for single-index vector collection:
[tabs]
====
Java::
+
--
[source,java]
----
VectorDocument<String> document = VectorDocument.of(
        "{'genre': 'novel', 'year': 1976}",
        VectorValues.of(
                new float[]{0.2f, 0.9f, -1.2f, 2.2f, 2.2f, 3.0f}
        )
);
----
--
Python::
+
--
[source,python]
----
document = Document(
    "{'genre': 'novel', 'year': 1976}",
    [
        Vector("", Type.DENSE, [0.2, 0.9, -1.2, 2.2, 2.2, 3.0]),
    ],
)
----
--
====

For multi-index collections, specify the names of the indexes to which the vectors belong:
[tabs]
====
Java::
+
--
[source,java]
----
VectorDocument<String> document = VectorDocument.of(
        "{'genre': 'fiction', 'year': 2022}",
        VectorValues.of(
                Map.of(
                        "word2vec-index", new float[] {0.2f, 0.9f, -1.2f, 2.2f, 2.2f, 3.0f},
                        "glove-index", new float[] {2f, 3f, 2f, 10f, -2f}
                )
        )
);
----
--
Python::
+
--
[source,python]
----
document = Document(
    "{'genre': 'novel', 'year': 1976}",
    [
        Vector("word2vec-index", Type.DENSE, [0.2, 0.9, -1.2, 2.2, 2.2, 3.0]),
        Vector("glove-index", Type.DENSE, [2, 3, 2, 10, -2]),
    ],
)
----
--
====


=== Put entries
To put single document to a vector collection, use the method `putAsync`, `putIfAbsent` or `setAsync` of the `VectorCollection` class.
[tabs]
====
Java::
+
--
[source,java]
----
VectorDocument<String> document = VectorDocument.of(
        "{'genre': 'novel', 'year': 1976}",
        VectorValues.of(new float[] {0.2f, 0.9f, -1.2f, 2.2f, 2.2f, 3.0f})
);
CompletionStage<VectorDocument<String>> result = vectorCollection.putAsync("1", document);
----
--
Python::
+
--
[source,python]
----
vectorCollection.put("1", Document(
    "{'genre': 'novel', 'year': 1976}",
    [
        Vector("", Type.DENSE, [0.2, 0.9, -1.2, 2.2, 2.2, 3.0]),
    ],
))
----
--
====

To put several documents to a vector collection, use the method `putAllAsync` of the `VectorCollection` class.
[tabs]
====
Java::
+
--
[source,java]
----
VectorDocument<String> document1 = VectorDocument.of("{'genre': 'novel', 'year': 1976}", VectorValues.of(new float[] {1.2f, -0.3f, 2.2f, 0.4f, 0.3f, 0.4f}));
VectorDocument<String> document2 = VectorDocument.of("{'genre': 'fiction', 'year': 2022}", VectorValues.of(new float[] {1.2f, -0.3f, 2.2f, 0.4f, 0.3f, -2.0f}));
CompletionStage<Void> result = vectorCollection.putAllAsync(
        Map.of("1", document1, "2", document2)
);
----
--
Python::
+
--
[source,python]
----
vectorCollection.put_all(
    {
        "1": Document(
            "{'genre': 'novel', 'year': 1976}",
            [
                Vector("", Type.DENSE, [1.2, -0.3, 2.2, 0.4, 0.3, 0.4]),
            ]),
        "2": Document(
            "{'genre': 'novel', 'year': 1976}",
            [
                Vector("", Type.DENSE, [1.2, -0.3, 2.2, 0.4, 0.3, -2.0]),
            ]),
    }
)
----
--
====

=== Read entries
To get document from a vector collection, use the method `getAsync` of the `VectorCollection` class.

[tabs]
====
Java::
+
--
[source,java]
----
CompletionStage<VectorDocument<String>> result = vectorCollection.getAsync("1");
----
--
Python::
+
--
[source,python]
----
vectorCollection.get("1")
----
--
====

=== Update entries
To update single entry in a vector collection, use the method `putAsync` or `setAsync` of the `VectorCollection` class.

[tabs]
====
Java::
+
--
[source,java]
----
VectorDocument<String> document = VectorDocument.of("{'genre': 'fiction', 'year': 2022}", VectorValues.of(new float[] {1.2f, -0.3f, 2.2f, 0.4f, 0.3f, 0.4f}));
CompletionStage<Void> result = vectorCollection.setAsync("1", document);
----
--
Python::
+
--
[source,python]
----
vectorCollection.set("1", Document("{'genre': 'fiction', 'year': 2022}",
    [
        Vector("", Type.DENSE, [1.2, -0.3, 2.2, 0.4, 0.3, 0.4]),
    ]
))
----
--
====

NOTE: When you update entry, you have to provide both `VectorDocument` and `VectorValues` even if only one of them is changed for the entry.

=== Delete entries
To delete document from a vector collection, use the method `deleteAsync` or `removeAsync` of the `VectorCollection` class.

[tabs]
====
Java::
+
--
[source,java]
----
CompletionStage<Void> resultDelete = vectorCollection.deleteAsync("1");
CompletionStage<VectorDocument<String>> resultRemove = vectorCollection.removeAsync("2");
----
--
Python::
+
--
[source,python]
----
vectorCollection.delete("1")
vectorCollection.remove("2")
----
--
====

NOTE: These methods do not delete vectors but mark them as deleted. This may impact search speed and memory usage. To permanently remove vectors from the index, you must run index optimization after deletion. See <<optimize-collection, optimize method>>

== Similarity search

Vector search returns entries with vectors that are most similar to the query vector, based on specified metrics. Any query consists of exactly one vector to search and search options, such as the limit of results to retrieve, etc. For more details about available options, refer to <<similarity-search-options, Similarity search options>>

For similarity search, use the `searchAsync` method of the `VectorCollection`.

In a single index vector collection, specifying the name of the index to search is not required.
However, for a multi-index vector collection, specifying the name of the index to search in is necessary.

Example for single-index vector collection:
[tabs]
====
Java::
+
--
[source,java]
----
CompletionStage<SearchResults<String, String>> results = vectorCollection.searchAsync(
        VectorValues.of(new float[] {0f, 0f, 0.2f, -0.3f, 1.2f, -0.5f}),
        SearchOptions.builder()
            .limit(5)
            .includeVectors()
            .includeValue()
            .build()
);
----
--
Python::
+
--
[source,python]
----
results = vectorCollection.search_near_vector(
    Vector("", Type.DENSE, [0, 0, 0.2, -0.3, 1.2, -0.5]),
    limit=5,
    include_value=True,
    include_vectors=True,
)
----
--
====

Example for multi-index vector collection:
[tabs]
====
Java::
+
--
[source,java]
----
CompletionStage<SearchResults<String, String>> results = vectorCollection.searchAsync(
        VectorValues.of("glove-index", new float[] {0f, 0f, 0.2f, -0.3f, 1.2f, -0.5f}),
        SearchOptions.builder()
            .limit(5)
            .includeVectors()
            .includeValue()
            .build()
);
----
--
Python::
+
--
[source,python]
----
results = vectorCollection.search_near_vector(
    Vector("glove-index", Type.DENSE, [0, 0, 0.2, -0.3, 1.2, -0.5]),
    limit=5,
    include_value=True,
    include_vectors=True,
)
----
--
====

=== Similarity search options
Search parameters are passed as an argument `searchOptions` to the searchAsync method.

.Search options
[cols="1,2,1",options="header"]
|===
|Option|Description|Default

|limit
|How many results should be returned in search result
|`10`

|includeValue
|Include the user value in the search result.
|`FALSE`


|includeVectors
|Include the vectors values in the search result.
|`FALSE`

|hints
|Extra hints for the search.
|`NULL`

|===


.Available hints
[cols="1,2",options="header"]
|===
|Hint|Description

|partitionLimit
|Number of results to fetch from each partition.

|memberLimit
|Number of results to fetch from member in 2-stage search.

|singleStage
|Force use of 1-stage search.

|===

[tabs]
====
Java::
+
--
[source,java]
----
var options = SearchOptions.builder()
                .limit(10)
                .includeValue()
                .includeVectors()
                .hint("partitionLimit", 1)
                .build();
----
--
====

WARNING: Hints allow fine-tuning some aspects of search execution but are subject to change and may be removed in future versions.

== Manage collection

=== Optimize collection

An optimization operation may be needed in the following cases:

* To permanently delete vectors that were marked for removal.
* After adding a significant number of vectors.
* The collection returns fewer vectors than expected.

WARNING: The optimization operation can be a time-consuming and resource-intensive process, and no mutating operations are allowed during this process.

[tabs]
====
Java::
+
--
[source,java]
----
CompletionStage<Void> result = vectorCollection.optimizeAsync("glove-index");
----
--
Python::
+
--
[source,python]
----
vectorCollection.optimize("glove-index")
----
--
====

=== Clear collection
To remove all vectors and values from the vector collection use the method `clearAsync()`.
[tabs]
====
Java::
+
--
[source,java]
----
CompletionStage<Void> result = vectorCollection.clearAsync();
----
--
Python::
+
--
[source,python]
----
vectorCollection.clear()
----
--
====

== Limitations in beta version

In current version Vector Collection is provided as Beta feature with some limitations, the most significant being:

1. API may be changed in future versions
2. Lack of rolling-upgrade compatibility guarantees for vector collections. It may be required to delete existing vector collections before migrating to future version of Hazelcast
3. Lack of fault tolerance, backups cannot yet be configured. However, data in collections is migrated to other cluster members in case of graceful shutdown and new member joining the cluster, so in case of lack of failures normal cluster maintenance (e.g. rolling restart) is possible without data loss.
4. Only on-heap storage of vector collections is available

