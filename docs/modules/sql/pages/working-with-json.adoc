= Working with JSON Data in SQL
:description: In Hazelcast, the SQL service supports two data types for JSON data: JSON-FLAT, which does not allow you to query nested keys/values and JSON, which supports nested queries and JSON functions.
:page-beta: true

JSON is a semi-structured data type used for holding JSON (JavaScript Object Notation) data. In Hazelcast, the SQL service supports the following data types for JSON data:

- `JSON`: Allows you to map JSON data to a single column and use xref:functions-and-operators.adoc#jsonpath[JsonPath] syntax to query any keys/values, including nested levels.
- `JSON-FLAT`: Allows you to map JSON data to columns and query only top-level keys/values.

== JSON

The `JSON` data type comes with full support for querying JSON in maps, Kafka topics, and files.

To query JSON data, you can use the following built-in functions that allow you read JSON values from a column:

- xref:functions-and-operators.adoc#json-functions[JSON_QUERY]
- xref:functions-and-operators.adoc#json-functions[JSON_VALUE]
- xref:functions-and-operators.adoc#json-functions[JSON_ARRAY]
- xref:functions-and-operators.adoc#json-functions[JSON_OBJECT]

With the `JSON` data type, you can map JSON data to a single column, using the xref:create-mapping.adoc[`CREATE MAPPING` statement].

For example, consider the following JSON data:

```json
"countries": [
  {
  "country":"United Kingdom",
  "cities": [{"city": "London"}]
  },
  {
  "country":"France",
  "cities": [{"city": "Lyon"}]
  },
  {
  "country":"Turkey",
  "cities": [{"city": "Istanbul"}]
  }
]
```

To map the JSON data type to a value in a map:

```sql
CREATE MAPPING countries
type IMap OPTIONS('keyFormat'='int', 'valueFormat'='json');
```

This statement creates a mapping to a map with two columns where the key is an `INTEGER` and the value is `JSON`:

- `__key`: A key as an integer
- `this`: JSON data

To insert entries into the map, you can use the xref:sink-into.adoc[`INSERT INTO` or `SINK INTO` statements].

```SQL
INSERT INTO countries
  VALUES (1, '{"countries": [
  {
  "country":"United Kingdom",
  "cities": [{"city": "London"}]
  },
  {
  "country":"France",
  "cities": [{"city": "Lyon"}]
  },
  {
  "country":"Turkey",
  "cities": [{"city": "Istanbul"}]
  }
]}');
```

To query and/or filter JSON, use the <<jsonpath, JsonPath>> syntax in the built-in JSON functions.

=== JsonPath

JsonPath is a query language for JSON.

Some JSON functions require JsonPath as a `json_path` parameter. This path identifies the values that you want to get from the `jsonArg` parameter, which can be a JSON parameter or a JSON-formatted string.

.Example JSON-formatted string
```json
'{"company" : {"employees" : [{"id" : "1","name":"jordan"}]}}'
```

.Example JSON
```sql
INSERT INTO employees VALUES (1, JSON_ARRAY(1,2,3))
```

.Example HazelcastJsonValue
```java
hzInstance.getSql().execute("INSERT INTO countries VALUES (?, ?)", 1L, new HazelcastJsonValue(countriesString));
```

The `json_path` parameter must be in the JsonPath format, which starts with a dollar (`$`) operator that refers to the root level of the JSON-formatted string.

[cols="20%m,80%a"]
|===
|JsonPath|Result

|
```sql
SELECT
   JSON_QUERY(this, '$')
   FROM countries;
```
|
```json
{"countries":[{"country":"United Kingdom","cities":[{"city":"London"}]},{"country":"France","cities":[{"city":"Lyon"}]},{"country":"Turkey","cities":[{"city":"Istanbul"}]}]}
```

|
```sql
SELECT
   JSON_QUERY(this, '$..cities' WITH WRAPPER)
   FROM countries;
```
|
```json
[{"city": "London"},{"city": "Lyon"},{"city": "Istanbul"}]
```

|
```sql
SELECT
   JSON_QUERY(this, '$.countries.*' WITH WRAPPER)
   FROM countries;
```
|
```json
["United Kingdom",{"city": "London"},"France",{"city": "Lyon"},"Turkey",{"city": "Istanbul"}]
```

|
```sql
SELECT
   JSON_QUERY(this, '$.countries..cities' WITH WRAPPER)
   FROM countries;
```
|
```json
["London","Lyon","Istanbul"]
```

|
```sql
SELECT
   JSON_QUERY(this, '$.countries[2]')
   FROM countries;
```
|
```json
{"country":"Turkey","cities":[{"city":"Istanbul"}]}
```

|
```sql
SELECT
   JSON_QUERY(this, '$.countries[0,1]')
   FROM countries;
```
|
```json
[{"country":"United Kingdom","cities":[{"city":"London"}]},{"country":"France","cities":[{"city":"Lyon"}]}]
```

|===

If the JsonPath does not match a value, `NULL` is returned.

If the JsonPath is invalid, the following exception is thrown: `com.hazelcast.com.jayway.jsonpath.InvalidPathException`.

=== Supported JsonPath Operators

These are the supported operators from the JsonPath standard.

[cols="20%m,80%a"]
|===
|Operator|	Description

|$
|Root

|@
|Current node

|*
|Wildcard

|..
|Recursive descent

|.<name>
|Child

|['<name>' (, '<name>')]
|Children

|[<number> (, <number>)]
|Indexes

|?(<expression>)
|Filter expression
|===

== JSON-FLAT

The `JSON-FLAT` data type comes with partial support for querying JSON.

This data type allows you to map JSON data to columns and only query top-level keys/values.

For example, consider the following JSON data:

```json
"countries": "United Kingdom",
"cities": "London"
```

To map the JSON data to a value in a map:

```sql
CREATE MAPPING cities (
__key INT,
countries VARCHAR,
cities VARCHAR)
type IMap OPTIONS('keyFormat'='int', 'valueFormat'='json-flat');
```

This statement creates a mapping to a map that expects three columns:

- `__key`: A key as an integer
- `countries`: A string
- `cities`: A string

```SQL
INSERT INTO cities VALUES
(1, 'United Kingdom','London');
```

To query the JSON value, select the column names.

```sql
SELECT cities AS City, countries AS Country
FROM cities;
```

```
+--------------------+--------------------+
|City                |Country             |
+--------------------+--------------------+
|London              |United Kingdom      |
+--------------------+--------------------+
```