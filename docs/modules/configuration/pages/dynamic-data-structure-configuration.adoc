= Dynamic Configuration
:description: Dynamic configuration allows you to temporarily or permanently add configuration to members for some features at runtime. This feature is useful if you want to configure a data structure without having to shut down cluster members.
[[dynamically-adding-data-structure-configuration-on-a-cluster]]

{description}

NOTE: Persistence for dynamic configuration is a beta feature.

== Supported Configuration

Dynamic configuration is supported for the following:

- Map
- Cache
- Queue
- List
- Set
- MultiMap
- ReplicatedMap
- RingBuffer
- Topic
- ReliableTopic
- Executor
- DurableExecutor
- ScheduledExecutor
- CardinalityEstimator
- PNCounter
- FlakeIdGenerator
- WAN (only with the REST API)

== In-Memory vs Persisted Changes

Dynamic configuration can be added in-memory or it can be persisted to a configuration file.

In-memory changes are temporary because they are stored in volatile memory and are lost when a cluster restarts.

Persisted changes are written to a YAML or XML configuration file so that you can reapply those changes if a cluster restarts.

To allow changes to be persisted, you must enable persistence for dynamic configuration. See xref:dynamic-config-options.adoc[].

== Adding Dynamic Configuration

To add dynamic configuration at runtime, you can use the following options:

- xref:dynamic-config-java.adoc[Java client API or Java member API]
- xref:dynamic-config-rest.adoc[REST API]

== Dynamic Data Structure Configuration and User Customizations

Dynamic configurations may reference
user customizations such as a user-provided `MapLoader` implementation referenced
by a `MapConfig`. User customizations can usually be configured using either of the following:

* Specifying a class or factory class name, such as `MapStoreConfig.setClassName`, and letting the
Hazelcast members instantiate the object.
* Providing an existing instance, such as, `MapStoreConfig.setImplementation`.

When dynamically adding a new data structure configuration with user customizations,
take the following considerations into account:

* For the user customizations submitted as a class name or factory class name, the referenced
classes are resolved lazily. Therefore, they should be either already on each member's local
classpath or resolvable via xref:clusters:deploying-code-on-member.adoc[user code deployment].
* When the user customizations are submitted as instances (or similarly factory instances),
the instances themselves have to be serializable. This is because the entire configuration needs
to be sent over the network to all cluster members, and their classes have to be available
on each member's local classpath.