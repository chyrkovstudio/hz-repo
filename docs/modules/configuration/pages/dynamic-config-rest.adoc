= Adding Dynamic Configuration in REST
:description: You can use the REST API to add dynamic configuration to some supported features at runtime.
:page-beta: true

{description}

You have two options for add dynamic configuration:

- <<edit-reload, Edit the configuration file>> that a member has already loaded and tell the member to reload that file, using the `/reload` endpoint.
- <<update, Send a member new configuration blocks>> to apply to the cluster, using the `/update` endpoint.

== Before you Begin

The REST API and the `CLUSTER_WRITE` endpoint group must be enabled on your cluster. See xref:maintain-cluster:rest-api.adoc[].

You need an Enterprise license.

include::partial$prereqs-dynamic-config.adoc[]

== What to Change

Dynamic changes to configurations files require only the `hazelcast` root followed by the new configuration block. For example, to add configuration for a map called `new-map`:

.Example of a new configuration
[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast> <1>
    <map name="new-map"> <2>
      <backup-count>
        2
      </backup-count>
    </map>
</hazelcast>
----
--

YAML::
+
[source,yaml]
----
hazelcast:
  map:
    new-map:
      backup-count: 2
----
====

<1> The `hazelcast` root.
<2> The configuration block for `new-map`.

[[edit-reload]]
== Editing and Reloading a Configuration File

. Open a member's configuration file and add some new configuration. For example, you may want to configure a new map with a backup count.
+
.Example of a new configuration
[tabs] 
==== 
XML:: 
+ 
-- 
[source,xml]
----
<hazelcast>
    <map name="new-map">
      <backup-count>
        2
      </backup-count>
    </map>
</hazelcast>
----
--

YAML::
+
[source,yaml]
----
hazelcast:
  map:
    new-map:
      backup-count: 2
----
====

. Send a `POST` request to the `/reload` endpoint of a cluster member.
+
- If your cluster has security enabled, send the cluster password in the request.
+
[source,shell]
----
curl -X POST -H "Content-Type: text/plain" --data-urlencode "<cluster-name>" --data-urlencode "<cluster-password>" http://localhost:5701/hazelcast/rest/config/reload
----

- If your cluster does not have security enabled, send the password as an empty string.
+
[source,shell]
----
curl -X POST -H "Content-Type: text/plain" --data-urlencode "<cluster-name>" --data-urlencode "" http://localhost:5701/hazelcast/rest/config/reload
----

When the member receives the request, it will check if the configuration already exists and propagate any new configuration across the rest of the cluster as well as those that may join the cluster later.

You should see the new configuration in the response's `addedConfigs` field:

```json
{"status":"success","message":"Configuration Update successfully finished.","result":{"addedConfigs":[{"sectionName":"map","configName":"new-map"}],"ignoredConfigs":[]}}
```

If you send the same request again, the member will ignore the configuration changes and return them in the response. See <<handling-configuration-conflicts,  Handling Configuration Conflicts>> 

```json
{"status":"success","message":"Configuration Update successfully finished.","result":{"addedConfigs":[],"ignoredConfigs":[{"sectionName":"map","configName":"new-map"}]}}
```

[[update]]
== Updating Configuration in a Request 

NOTE: The configuration must be URL encoded.

If your cluster has security enabled, send the cluster password in the request.

[source,shell]
----
curl -X POST -H "Content-Type: text/plain" --data-urlencode "<cluster-name>" --data-urlencode "<cluster-password>" --data-urlencode "
hazelcast:
  map:
    new-map:
      backup-count: 2
" http://localhost:5701/hazelcast/rest/config/update
----

If your cluster does not have security enabled, send the password as an empty string.

[source,shell]
----
curl -X POST -H "Content-Type: text/plain" --data-urlencode "<cluster-name>" --data-urlencode "" --data-urlencode "
hazelcast:
  map:
    new-map:
      backup-count: 2
" http://localhost:5701/hazelcast/rest/config/update
----

include::partial$dyn-config-partial-propagation.adoc[leveloffset=+1]

[[handling-configuration-conflicts]]
== Handling Configuration Conflicts

The REST API endpoints are idempotent. If you add a dynamic configuration for an block that already exists, the member will ignore the request and return the change you requested in the `ignoredConfigs` field.

.Example conflict response
[source,json]
----
{"status":"success","message":"Configuration Update successfully finished.","result":{"addedConfigs":[],"ignoredConfigs":[{"sectionName":"map","configName":"(%)"}]}}
----